use std::{fs::File, io::stdout, path::PathBuf, thread::sleep, time::Duration};

use alloy::primitives::{Address, U256};
use clap::Parser;
use espresso_contract_deployer::{
    build_provider, builder::DeployerArgsBuilder, network_config::light_client_genesis, Contract,
    Contracts, DeployedContracts,
};
use espresso_types::{config::PublicNetworkConfig, parse_duration};
use hotshot_types::light_client::STAKE_TABLE_CAPACITY;
use sequencer_utils::logging;
use tide_disco::error::ServerError;
use url::Url;
use vbs::version::StaticVersion;

/// Deploy contracts needed to run the sequencer.
///
/// This script deploys contracts needed to run the sequencer to an L1. It outputs a .env file
/// containing the addresses of the deployed contracts.
///
/// This script can also be used to do incremental deployments. The only contract addresses
/// needed to configure the sequencer network are ESPRESSO_SEQUENCER_FEE_CONTRACT_PROXY_ADDRESS,
/// ESPRESSO_SEQUENCER_LIGHT_CLIENT_PROXY_ADDRESS and ESPRESSO_SEQUENCER_STAKE_TABLE_ADDRESS.
/// These contracts, however, have dependencies, and a full deployment involves several
/// contracts. Some of these contracts, especially libraries may already have been deployed, or
/// perhaps one of the top-level contracts has been deployed and we only need to deploy the other
/// one.
///
/// It is possible to pass in the addresses of already deployed contracts, in which case those
/// addresses will be used in place of deploying a new contract wherever that contract is required
/// in the deployment process. The generated .env file will include all the addresses passed in as
/// well as those newly deployed.
#[derive(Clone, Debug, Parser)]
struct Options {
    /// A JSON-RPC endpoint for the L1 to deploy to.
    #[clap(
        short,
        long,
        env = "ESPRESSO_SEQUENCER_L1_PROVIDER",
        default_value = "http://localhost:8545"
    )]
    rpc_url: Url,

    /// Request rate when polling L1.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_L1_POLLING_INTERVAL",
        default_value = "7s",
        value_parser = parse_duration,
    )]
    pub l1_polling_interval: Duration,

    /// URL of a sequencer node that is currently providing the HotShot config.
    /// This is used to initialize the stake table.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_URL",
        default_value = "http://localhost:24000"
    )]
    pub sequencer_url: Url,

    /// Mnemonic for an L1 wallet.
    ///
    /// This wallet is used to deploy the contracts, so the account indicated by ACCOUNT_INDEX must
    /// be funded with with ETH.
    #[clap(
        long,
        name = "MNEMONIC",
        env = "ESPRESSO_SEQUENCER_ETH_MNEMONIC",
        default_value = "test test test test test test test test test test test junk"
    )]
    mnemonic: String,

    /// Address for the multisig wallet that will be the admin
    ///
    /// If provided, this the multisig wallet that will be able to upgrade contracts and execute
    /// admin only functions on contracts. If not provided, admin power for all contracts will be
    /// held by the account used to deploy the contracts (determined from MNEMONIC, ACCOUNT_INDEX).
    #[clap(
        long,
        name = "MULTISIG_ADDRESS",
        env = "ESPRESSO_SEQUENCER_ETH_MULTISIG_ADDRESS"
    )]
    multisig_address: Option<Address>,

    /// Account index in the L1 wallet generated by MNEMONIC to use when deploying the contracts.
    #[clap(
        long,
        name = "ACCOUNT_INDEX",
        env = "ESPRESSO_DEPLOYER_ACCOUNT_INDEX",
        default_value = "0"
    )]
    account_index: u32,

    /// Option to deploy fee contracts
    #[clap(long, default_value = "false")]
    deploy_fee: bool,
    /// Option to deploy LightClient V1 and proxy
    #[clap(long, default_value = "false")]
    deploy_light_client_v1: bool,
    /// Option to upgrade to LightClient V2
    #[clap(long, default_value = "false")]
    upgrade_light_client_v2: bool,
    #[clap(long, default_value = "false")]
    deploy_esp_token: bool,
    #[clap(long, default_value = "false")]
    deploy_stake_table: bool,

    /// Write deployment results to OUT as a .env file.
    ///
    /// If not provided, the results will be written to stdout.
    #[clap(short, long, name = "OUT", env = "ESPRESSO_DEPLOYER_OUT_PATH")]
    out: Option<PathBuf>,

    #[clap(flatten)]
    contracts: DeployedContracts,

    /// If toggled, launch a mock LightClient contract with a smaller verification key for testing.
    /// Applies to both V1 and V2 of LightClient.
    #[clap(short, long)]
    pub use_mock: bool,

    /// Stake table capacity for the prover circuit
    #[clap(short, long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_CAPACITY", default_value_t = STAKE_TABLE_CAPACITY)]
    pub stake_table_capacity: usize,
    ///
    /// If the light client contract is being deployed and this is set, the prover will be
    /// permissioned so that only this address can update the light client state. Otherwise, proving
    /// will be permissionless.
    ///
    /// If the light client contract is not being deployed, this option is ignored.
    #[clap(long, env = "ESPRESSO_SEQUENCER_PERMISSIONED_PROVER")]
    permissioned_prover: Option<Address>,

    /// Exit escrow period for the stake table contract.
    ///
    /// This is the period for which stake table contract will retain funds after withdrawals have
    /// been requested. It should be set to a value that is at least 3 hotshot epochs plus ample
    /// time to allow for submission of slashing evidence. Initially it will probably be around one
    /// week.
    #[clap(long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_EXIT_ESCROW_PERIOD", value_parser = parse_duration)]
    exit_escrow_period: Option<Duration>,

    /// The address that the tokens will be minted to.
    ///
    /// If unset the tokens will be minted to the deployer account.
    #[clap(long, env = "ESP_TOKEN_INITIAL_GRANT_RECIPIENT_ADDRESS")]
    initial_token_grant_recipient: Option<Address>,

    #[clap(flatten)]
    logging: logging::Config,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let opt = Options::parse();
    opt.logging.init();

    let mut contracts = Contracts::from(opt.contracts);

    let provider = build_provider(opt.mnemonic, opt.account_index, opt.rpc_url);

    // First use builder to build constructor input arguments
    let mut args_builder = DeployerArgsBuilder::default();
    args_builder
        .deployer(provider)
        .mock_light_client(opt.use_mock);
    if let Some(multisig) = opt.multisig_address {
        args_builder.multisig(multisig);
    }
    if let Some(token_recipient) = opt.initial_token_grant_recipient {
        args_builder.token_recipient(token_recipient);
    }

    if opt.deploy_light_client_v1 {
        let (genesis_state, genesis_stake) =
            light_client_genesis(&opt.sequencer_url, opt.stake_table_capacity).await?;
        args_builder
            .genesis_lc_state(genesis_state)
            .genesis_st_state(genesis_stake);
        if let Some(prover) = opt.permissioned_prover {
            args_builder.permissioned_prover(prover);
        }
    }
    if opt.upgrade_light_client_v2 {
        // fetch epoch length from HotShot config
        // Request the configuration until it is successful
        let (blocks_per_epoch, epoch_start_block) = loop {
            match surf_disco::Client::<ServerError, StaticVersion<0, 1>>::new(
                opt.sequencer_url.clone(),
            )
            .get::<PublicNetworkConfig>("config/hotshot")
            .send()
            .await
            {
                Ok(resp) => {
                    let config = resp.hotshot_config();
                    break (config.blocks_per_epoch(), config.epoch_start_block());
                },
                Err(e) => {
                    tracing::error!("Failed to fetch the network config: {e}");
                    sleep(Duration::from_secs(5));
                },
            }
        };
        args_builder
            .blocks_per_epoch(blocks_per_epoch)
            .epoch_start_block(epoch_start_block);
    }
    if opt.deploy_stake_table {
        if let Some(escrow_period) = opt.exit_escrow_period {
            args_builder.exit_escrow_period(U256::from(escrow_period.as_secs()));
        }
    }

    // then deploy specified contracts
    let args = args_builder.build()?;
    if opt.deploy_fee {
        args.deploy(&mut contracts, Contract::FeeContractProxy)
            .await?;
    }
    if opt.deploy_esp_token {
        args.deploy(&mut contracts, Contract::EspTokenProxy).await?;
    }
    if opt.deploy_light_client_v1 {
        args.deploy(&mut contracts, Contract::LightClientProxy)
            .await?;
    }
    if opt.upgrade_light_client_v2 {
        args.deploy(&mut contracts, Contract::LightClientV2).await?;
    }
    if opt.deploy_stake_table {
        args.deploy(&mut contracts, Contract::StakeTableProxy)
            .await?;
    }

    // finally print out or persist deployed addresses
    if let Some(out) = &opt.out {
        let file = File::options()
            .create(true)
            .truncate(true)
            .write(true)
            .open(out)?;
        contracts.write(file)?;
    } else {
        contracts.write(stdout())?;
    }

    Ok(())
}
