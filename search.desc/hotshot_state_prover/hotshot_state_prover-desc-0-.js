searchState.loadedDescShard("hotshot_state_prover", 0, "SNARK-assisted <code>HotShot</code> light client state update …\nState verifier circuit builder Circuit implementation for …\nUtilities for test\nProver service related functionalities A light client …\nSNARK proof generation\nLight client state Variable\nVariable for stake table entry\nLight client state Variable The stake table commitment is …\nA function that takes as input:\nInternal function to build a dummy circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nErrors\nErrors\nCommitment for QC verification keys\nStake amount\nCommitment for stake amount\nCommitment for state verification keys\nstate verification keys\nThreshold for quorum signatures\nNumber of block per epoch for testing\nOur “first epoch” in test is epoch 2: …\nMock of hotshot ledger for testing LightClient.sol …\nMock for system parameter of <code>MockLedger</code>\nStake table capacity used for testing\nreturns the current epoch\ncompute the epoch corresponding to <code>height</code>\nElapse a view with a new finalized block\nElapse a view without a new finalized block (e.g. …\nreturn true if epoch is activated\nnumber of block per epoch\nindicate the first epoch\nreturn the first epoch (activation epoch)\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn list of (proof, ver_key, public_input, extra_msg, …\nReturn the light client state and proof of consensus on …\na malicious attack, generating a fake stake table full of …\nInit the system parameters (some fixed, some adjustable)\nInitialize the ledger with genesis state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturn true of the current state is epoch root since it …\nreturn true of the current state is between epoch root and …\nHelper function for test\nReturns the light client state\nReturns epoch-aware stake table state for the next block. …\nmax capacity of stake table\nHelper function for test\nUpdate stake table with <code>num_reg</code> number of new …\nattempt to advance epoch, should be invoked at the …\nReturns the stake table state for current voting\nError when communicating with the smart contract: {0}\nInternal error: {0}\nInvalid light client state or signatures: {0}\nGeneral network issue: {0}\nInternal error when generating the SNARK proof: {0}\nError when communicating with the state relay server: {0}\nInternal error with the stake table: {0}\nConfiguration/Parameters used for hotshot state prover\nThis function will fetch the cross epoch state update …\nEpoch length in number of Hotshot blocks.\nThe configuration of the prover service\nThe current epoch number of the stake table\nThe epoch start block.\nGet the epoch-related  from the sequencer’s …\nGet the latest LightClientState and signature bundle from …\nInitialize the stake table from a sequencer node given the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAddress of LightClient proxy contract\nReturns both genesis light client state and stake table …\nMaximum number of retires for one-shot prover\nIf daemon and provided, the service will run a basic HTTP …\nURL of the chain (layer 1  or any layer 2) JSON-RPC …\nRead the following info from the LightClient contract …\nUrl of the state relay server (a CDN that sequencers push …\nInterval between retries if a state update fails\nRun light client state prover once\nURL of a node that is currently providing the HotShot …\nTransaction signing key for Ethereum or any other layer 2\nThe current stake table state\nThe stake table\nStake table capacity for the prover circuit.\nsubmit the latest finalized state along with a proof to …\nSync the light client state from the relay server and …\nInterval between light client state update\nProof\nProving key\nBLS verification key, base field and Schnorr verification …\nUniversal SRS\nVerifying key\n\\beta times the above generator of G2.\nDeserialize <code>Self</code> using <code>ark-serialize</code> (uncompressed)\nThe size of the evaluation domain. Should be a power of …\nReturns the argument unchanged.\nGiven a proving key and\nTODO: remove h and beta_h The generator of G2.\nGet the internal of verifying key, namely a curve Point\nCalls <code>U::from(self)</code>.\nA flag indicating whether the key is a merged key.\nThe constants K0, …, K_num_wire_types that ensure wire …\nThe number of public inputs.\nKZG PCS opening key.\n(Aggregated) proof of evaluations at challenge point <code>zeta</code>.\nThe partial proof for Plookup argument\nPlookup verifying key, None if not support lookup.\nPolynomial evaluations.\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\npowers of \\beta time the generator h of G2\nGiven a SRS, returns the proving key and verifying key for …\nThe polynomial commitment for the wire permutation …\nThe selector polynomial commitments. The commitments are …\nSerialize <code>Self</code> using <code>ark-serialize</code> (uncompressed)\n(Aggregated) proof of evaluation at challenge point …\nThe permutation polynomial commitments. The commitments …\nSplit quotient polynomial commitments.\nConvert the verification key into the affine form.\nThis should be compatible with our legacy implementation.\nSignature verification function\nThe verifying key. It is used by prover to initialize …\nWire witness polynomials commitments.")